时间复杂度分析：
backtrack不同题目的时间复杂度不一样。大概是O(N!)和O(2^N)，要用演算法来分析，就是T(1) + T(2) + T(3) + ... + T(N)
那些只需要一个count，或者int结果的backtrack，而不需要List<List<String>> 这类全过程的，大部分可以转换成DP来做。
如果是只需要一个类似List<String>结果的，也可以先用DP，再想办法DP往回走，找出结果，这类题目就太难了，应该仅限于点到为止，嘴巴上讲一讲。

一个具体例子的时间复杂度分析，可以参考DP里的115题。


模板，
一般都是用递归来做，递归方法里面带一个for或者while循环。最大的框架就是这样，递归，然后里面带循环。也可以参看22题我写的，自己用stack实现，但是每一个变量基本都需要一个stack来维持状态，手动的比较麻烦，递归的时候用系统自带的stack，相对更容易实现。

分两大类，有顺序还是没顺序。有顺序就是Permutation，没顺序就是Combination。有顺序意味着[1,2] 和[2,1]是不同的结果，里面的for循环可以每次都从0开始，所以没必要传入index。但是需要一个boolean数组作为判断前面是否已经用了该index对应的数值。而无序的话，[1,2] 和[2,1]表示相同的结果，不能重复返回。这里就需要用到一个很简单的概念，就是传入一个index，每次都从该index后面取值，前面的都表示重复了，不考虑，就不会出现重复。

这两大类每一类都又分为两种，一种是输入有重复数字，一种是没有重复数字。没有重复数字简单很多，有重复数字需要特别注意。在Permutation的时候，一定要用boolean数组，而不能用用set，因为重复的数字可以用在不同的位数。比如[1,1,1]， 如果有3个1. 去重的办法就是，同一个位数，前面相同的情况下，不能再用同一个数字，这一点看看代码就更直观的理解。Permutation的去重相对更麻烦一点点。记得一定要排序，不排序则无法去重。